# 그래프

- **그래프**
    - **그래프**
        - 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계 표현
        - 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료구조
        - 선형 자료구조나 트리로 표현하기 어려운 M : N의 관계를 표현한 것
        - V개의 정점을 가지는 그래프는 최대 V x (V - 1) / 2간선이 가능
    
    - **그래프 종류**
        - **무향 그래프(Undirected Graph)** & **유향 그래프(Directed Graph)**
        - **가중치 그래프(Weighted Graph)**
        - **순환 그래프(Cycle Graph)**
        - **비 순환 방향 그래프(DAG, Directed Acyclie Graph)**
    
    - **완전 그래프**
        - 정점들에 대해 가능한 모든 간선들을 가진 그래프
        - 모든 정점은 인접하다.
    
    - **부분 그래프**
        - 일부 간선들을 가진 그래프
    
    - **인접 (Adjacency)**
        - 두 개의 정점에 간선이 존재하면 서로 인접한 것
        - 완전 그래프에 속한 임의의 두 정점은 모두 인접
    
    - **경로(Path)**
        - 간선들을 순서대로 나열한 것
        - 하나의 정점을 한 번만 지나는 경로를 **단순 경로**라 한다.
        - 시작 정점에서 끝나는 경로를 **사이클(Cycle)**이라고 한다.
- **그래프 표현 방법**
    - 간선의 정보를 저장하는 방식, 메모리나 성능을 고려하여 결정
        - **인접 행렬(Adjacent Matrix)**
        - **인접 리스트(Adjacent List)**
        - **간선 배열(Edge Array)**
    
    - **인접 행렬(Adjacent Matrix)**
        - 두 정점을 연결하는 간선의 유무를 행렬로 표현
        - V x V개의 2차원 배열 (V는 정점의 개수, 정점의 번호가 1번부터 시작한다면 
        (V + 1) x (V + 1)개의 2차원 배열)
        - 행 번호화 열 번호는 그래프의 정점 번호
        - 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현 (가중치가 있다면 해당 값으로 작성)
        - 무향 그래프 >> i번째 행의 합 = i번째 열의 합 = V_i의 차수
        - 유향 그래프 >> i번째 행의 합 = V_i의 진출 차수, i번째 열의 합 = V_i의 진입 차수
    
    - **인접 리스트**
        - 각 정점에 대한 인접 정점들을 순차적으로 표현
        - 하나의 정점에 대한 인접 정점들을 각 노드로 하는 연결리스트로 저장
    
    - **간선 배열**
        - 정점과 정점의 연결 정보인 간선을 배열에 저장
        - 간선을 표현하는 두 정점의 정보를 배열 혹은 객체로 저장할 수 있음
    
- **그래프 탐색**
    - 모든 노드를 빠짐 없이 탐색하는 방법은 두 가지가 있따.
        - **깊이 우선 탐색(Depth First Search, DFS)**
        - **너비 우선 탐색(Breadth First Search, BFS)**
    
    - **깊이 우선 탐색(DFS)**
        - 시작 지점에서 출발하여 한 방향으로 탐색함
        - 진행할 수 없다면 마지막에 만난 지점으로 돌아와 다른 방향 다시 탐색
        - 후입 선출(LIFO) 구조의 **스택(Stack)** 사용
        - 재귀함수는 System Stack을 활용하므로 간단하게 구현 가능
    
    - **너비 우선 탐색(BFS)**
        - 시작 지점에 인접한 순으로 탐색을 시작함
        - 인접한 지점을 모두 방문하였다면 다음으로 인접한 지점을 방문함
        - 선입 선출(FIFO) 구조의 **큐(Queue)** 사용
        - 너비 우선 탐색은 인접한 지점부터 방문을 하므로 시작 지점과 끝 지점이 주어졌을 때 **최단 길이**를 구할 수 있다.
- **서로소 집합**
    - **상호 배타 집합**
        - 중복 포함된 원소가 없는 집합 >> 교집합이 없다
        - 각 집합은 대표자를 통해 구분
    
    - **상호 배타 집합 표현 방법**
        - **트리**
        - **연결리스트**
    
    - 상호 배타 집합 연산
        - **Make-Set(x)**
        - **Find-Set(x) : 대표를 찾는 것**
        - **Union(x, y) : 합치는 것, 대표는 x**
    
    - **상호 배타 집합 표현 - 연결리스트**
        - 같은 집합의 원소들은 하나의 연결리스트로 관리
        - 연결리스트의 맨 앞의 원소를 집합의 대표자로 결정
        - 각 원소는 집합의 대표 원소를 가리키는 링크를 갖는다.
    
    - **상호 배타 집합 표현 - 트리**
        - 하나의 집합을 하나의 트리로 표현한다
        - 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다.
    
    - **연산의 효율을 높이는 방법**
        - Rank를 이용한 Union
            - 각 노드는 자신을 루트로 하는 subtree의 높이를 랭크(rank)라는 이름으로 저장
            - 두 집합을 Union할 때 **rank가 낮은 집합을 높은 집합**에 붙인다.
        - Path Compression
            - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 대표를 가리키도록 
            수정한다.
    
    - **Make_set( ) 연산**
        - 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
        - 반복문을 이용하여 간소화
        - p[x] : 노드 x의 부모 저장
        - rank[x] : 루트 노드가 x인 트리의 랭크 값 저장
    
    - **Find-Set연산**
        - Find-Set(x) : x를 포함하는 집합을 찾는 연산
        - 특정 노드에서 루트 노드까지의 경로를 찾아 가면서 노드 부모의 정보를 갱신
        
        ```java
        private static int findset(int x) {		
        
        		if (x != p[x]) 
        			p[x] = findset(p[x]);
        			
        		return p[x];
        }
        ```
        
    
    - **Union 연산**
        - Union(x, y) : x와 y를 포함하는 두 집합을 합하는 연산
        
        ```java
        private static void union(int x, int y) {
        		
        		x = findset(x);
        		y = findset(y);
        
        		if (x != y) {
        			p[y] = x;
        		}
        }
        ```
        
- **최소 비용 신장 트리(Minimum Spanning Tree)**
    - **신장 트리**
        - 그래프의 모든 정점과 간선의 부분 집합으로 구성되는 트리
    
    - **최소 신장 트리**
        - 신장 트리 중에서 사용된 **간선들의 가중치 합이 최소인 트리**
        - 무방향 가중치 그래프
        - N개의 정점을 가지는 그래프에 대해 **반드시 (N - 1)개의 간선을 사용**
        - 사이클을 포함하지 않는다.
    
    - **사용하는 이유**
        - 도로망, 통신망, 유통망 등등 여러 분야에서 비용을 최소로 해야 이익을 볼 수 있다.
        - 대표적인 알고리즘으로 **크루스칼**, **프림**이 있다.
    - **풀어 볼 만한 문제**
        - BOJ_1197 - [최소 스패닝 트리](https://www.acmicpc.net/problem/1197)
        - BOJ_1922 - [네트워크 연결](https://www.acmicpc.net/problem/1922)
        - SWEA_1251 - [하나로](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15StKqAQkCFAYD&categoryId=AV15StKqAQkCFAYD&categoryType=CODE&problemTitle=1251&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)
        - SWEA_3289 - [서로소 집합](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWBJKA6qr2oDFAWr&categoryId=AWBJKA6qr2oDFAWr&categoryType=CODE&problemTitle=3289&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)
- **크루스칼 알고리즘**
    - **크루스칼 알고리즘**
        - 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
        - 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
        사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
        - (N - 1)개의 간선이 선택될 때 까지 바로 위의 단계를 반복
- **프림(Prim) 알고리즘**
    - **하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식**
        - **임의의 정점**을 선택하여 시작
        - 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
        - 모든 정점이 선택될 때 까지 바로 위의 과정을 반복
    
    - 서로소인 2개의 집합 정보를 유지
        - 트리 정점 : MST를 만들기 위해 선택된 정점들
        - 비트리 정점들 : 선택 되지 않은 정점들
    
    - **프림 알고리즘(반복문)**
        
        ```java
        import java.util.Arrays;
        import java.util.Scanner;
        
        public class 프림_반복문 {
        
        	static final int INF = Integer.MAX_VALUE;	// 큰 값으로 초기화
        	
        	public static void main(String[] args) {
        		Scanner sc = new Scanner(input);
        	
        		int V = sc.nextInt();	// 0부터 시작
        		int E = sc.nextInt();	
        		
        		// 인접행렬
        		int[][] adjArr = new int[V][V];
        		
        		for (int i = 0; i < E; i++) {
        			int A = sc.nextInt();
        			int B = sc.nextInt();
        			int W = sc.nextInt();
        			// 무향그래프
        			adjArr[A][B] = adjArr[B][A] = W;
        		}
        		
        		// 방문처리를 위해 배열선언
        		boolean[] visit = new boolean[V];
        		int[] p = new int[V];	// 어디에서 왔는지
        		int[] dist = new int[V];	// key라고 했던 가장 작은 비용을 저장하기 위한 배열
        		
        		// dist초기화 방법 1
        		for (int i = 0; i < V; i++) {
        			dist[i] = INF;
        			p[i] = -1;
        		}
        		
        		Arrays.fill(dist, INF);	// dist배열을 INF로 초기화 방법 2
        		
        		// 임의의 한 점을 선택해서 돌림
        		dist[0] = 0;	// 0번 정점부터 시작하겠다는 의미
        		
        		int ans = 0;
        		for (int i = 0; i < V - 1; i++) {
        			
        			int min = INF;
        			int idx = -1;
        			
        			// 아직 안뽑힌 정점 중 가장 작은 값을 뽑음
        			for (int j = 0; j < V; j++) {
        				
        				if (!visit[j] && dist[j] < min) { 
        					min = dist[j];
        					idx = j;
        				}
        			}	// for문 종료 시 idx : 가장 작은 값을 가지고 있고 방문하지 않은 정점이 선택 된다.
        			
        			visit[idx] = true;
        			
        			// 뽑은 정점과 인접한 정점들 중 갱신할 수 있으면 갱신
        			for (int j = 0; j < V; j++) {
        				
        				if (!visit[j] && adjArr[idx][j] != 0 && dist[j] > adjArr[idx][j]) {
        					dist[j] = adjArr[idx][j];
        					p[j] = idx;
        				}
        			}
        		}	// 정점을 선택하는 사이클
        		
        		for (int i = 0; i < V; i++) {
        			ans += dist[i];
        		}
        		System.out.println(Arrays.toString(dist));
        		System.out.println(Arrays.toString(p));
        		System.out.println(ans);
        	}
        	
        	static String input ="7 11\r\n"
        			+ "0 1 32\r\n"
        			+ "0 2 31\r\n"
        			+ "0 5 60\r\n"
        			+ "0 6 51\r\n"
        			+ "1 2 21\r\n"
        			+ "2 4 46\r\n"
        			+ "2 6 25\r\n"
        			+ "3 4 34\r\n"
        			+ "3 5 18\r\n"
        			+ "4 5 40\r\n"
        			+ "4 6 51\r\n"
        			+ "";
        }
        ```
        
    - **프림 알고리즘(우선순위 큐)**
        
        ```java
        import java.util.ArrayList;
        import java.util.Arrays;
        import java.util.List;
        import java.util.PriorityQueue;
        import java.util.Scanner;
        
        public class 프림_우선순위큐 {
        
        	static final int INF = Integer.MAX_VALUE;	// 큰 값으로 초기화
        	
        	static class Edge implements Comparable<Edge> {
        		int st, ed, w;
        		
        		public Edge(int st, int ed, int w) {
        			this.st = st;
        			this.ed = ed;
        			this.w = w;
        		}
        
        		@Override
        		public int compareTo(Edge o) {
        			return Integer.compare(this.w, o.w);
        		}
        	}
        	
        	public static void main(String[] args) {
        		Scanner sc = new Scanner(input);
        	
        		int V = sc.nextInt();	// 0부터 시작
        		int E = sc.nextInt();	
        		
        		// 인접리스트
        		List<Edge>[] adjList = new ArrayList[V];
        		
        		for (int i = 0; i < V; i++) adjList[i] = new ArrayList<>();
        		
        		for (int i = 0; i < E; i++) {
        			int A = sc.nextInt();
        			int B = sc.nextInt();
        			int W = sc.nextInt();
        			// 무향그래프
        			adjList[A].add(new Edge(A, B, W));
        			adjList[B].add(new Edge(B, A, W));
        		}
        		
        		// 방문처리를 위한 배열
        		boolean[] visit = new boolean[V];
        		
        		PriorityQueue<Edge> pq = new PriorityQueue<>();
        		
        		visit[0] = true;	// 0번 정점은 시작정점
        		
        		// 0번 정점과 인접한 정점을 전부 넣음
        //		for (int i = 0; i < adjList[0].size(); i++) {
        //			pq.add(adjList[0].get(i));
        //		}		
        //		for (Edge e : adjList[0]) {
        //			pq.add(e);
        //		}
        		
        		pq.addAll(adjList[0]);
        		
        		int pick = 1;	// 현재 확보한 정점의 개수
        		int ans = 0;	// 비용
        		
        		while (pick != V) {
        			
        			Edge e = pq.poll();
        			// 2번 정점은 st와 ed 중 ed에 들어있다.
        			if (visit[e.ed]) continue;	// Edge e에 들어있는 도착점 ed가 이미 방문한 점인 경우
        			
        			ans += e.w;	// 방문한 점이 아니라면 해당 간선이 가지고 있는 가중치를 더한다.
        			visit[e.ed] = true;
        			pick++;
        			
        			// 반복문을 돌면서 갱신할 수 있는 것 전부 갱신
        			pq.addAll(adjList[e.ed]);
        		}
        		
        		System.out.println(ans);
        	}
        	
        	static String input ="7 11\r\n"
        			+ "0 1 32\r\n"
        			+ "0 2 31\r\n"
        			+ "0 5 60\r\n"
        			+ "0 6 51\r\n"
        			+ "1 2 21\r\n"
        			+ "2 4 46\r\n"
        			+ "2 6 25\r\n"
        			+ "3 4 34\r\n"
        			+ "3 5 18\r\n"
        			+ "4 5 40\r\n"
        			+ "4 6 51\r\n"
        			+ "";
        }
        ```
        
- **다익스트라(Dijkstra) 알고리즘**
    - **최단 경로정의**
        - 가중치가 있는 그래프에서 두 정점 사이의 경로들 중 간선의 가중치의 합이 최소인 경로
    
    - **하나의 시작 정점에서 끝 정점까지의 최단 경로**
        - 다익스트라(Dijkstra) 알고리즘 (음의 가중치 허용 X)
        - ~~벨만-포드(Bellman-Ford) 알고리즘 (음의 가중치 허용O)~~
    
    - **모든 정점들에 대한 최단 경로**
        - 플로이드-워셜(Floyd-Warshall) 알고리즘
    
    - **다익스트라 알고리즘**
        - **시작 정점에서 거리가 최소인 정점을 선택**해 나가면서 최단 경로를 구하는 방식
        - 탐욕 알고리즘 중 하나이고, 프림 알고리즘과 유사
        - 정점 A에서 정점 B까지의 최단 경로 (A → X → B)
    
    - **다익스트라 알고리즘 동작 과정**
        - 시작 정점 입력
        - 거리 저장 배열을 INF로 초기화
        - 시작점에서 갈 수 있는 곳의 값 갱신
        - 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
        - 방문하지 않은 점들이 가지고 있는 거리 값과 현재 정점에서 방문하지 않은 
        정점까지의 가중치의 합이 작다면 갱신
        - 모든 정점을 방문할 때까지 반복
    
    - 다익스트라 알고리즘(반복문)
        
        ```java
        public class 다익스트라_반복문 {
        
        	static class Node {
        		
        		int v, w;
        		
        		public Node (int v, int w) {
        			this.v = v;
        			this.w = w;
        		}
        	}
        	
        	static final int INF = Integer.MAX_VALUE;
        	static int V, E;
        	static List<Node>[] adjList;	// 인접리스트
        	static int[] dist;	// 거리 배열
        	
        	public static void main(String[] args) {
        		Scanner sc = new Scanner(System.in);
        		
        		int V = sc.nextInt();	// 정점의 개수
        		int E = sc.nextInt();	// 간선의 개수
        		
        		adjList = new ArrayList[V];
        		for (int i = 0; i < V; i++) adjList[i] = new ArrayList<>();
        		
        		dist = new int[V];
        		Arrays.fill(dist, INF);
        		
        		for (int i = 0; i < E; i++) 
        			// 시작정점 - 도착정점 - 가중치 순으로 입력
        			adjList[sc.nextInt()].add(new Node(sc.nextInt(), sc.nextInt()));
        		
        		Dijkstra(0);
        		
        		System.out.println(Arrays.toString(dist));
        	}
        
        	private static void Dijkstra(int start) {
        		
        		boolean[] visit = new boolean[V];	// 방문처리
        		dist[start] = 0;	// 시작 노드까지의 거리는 0으로 초기화
        		
        		for (int i = 0; i < V - 1; i++) {
        			
        			int min = INF;
        			int idx = -1;
        			
        			for (int j = 0; j < V; j++) {
        				
        				if (!visit[j] && min > dist[j]) {
        					min = dist[j];
        					idx = j;
        				}
        			}	// idx : 방문하지 않았으면서, 시작 정점으로부터 
        			  // 해당 idx 정점까지의 거리가 최소인 정점의 번호 
        			
        			visit[idx] = true;
        			
        			for (Node node : adjList[idx]) {				
        				if (!visit[node.v] && dist[node.v] > dist[idx] + node.w) 
        					dist[node.v] = dist[idx] + node.w;
        			}
        		}		
        	}	// Dijkstra
        }
        ```
        
    - 다익스트라 알고리즘(우선순위 큐)
        
        ```java
        static class Node implements Comparable<Node>{
        		
        		int v, w;
        		
        		public Node (int v, int w) {
        			this.v = v;
        			this.w = w;
        		}
        
        		@Override
        		public int compareTo(Node o) {
        			return Integer.compare(this.w, o.w);
        		}
        	}
        	
        	static final int INF = Integer.MAX_VALUE;
        	static int V, E;
        	static List<Node>[] adjList;	// 인접리스트
        	static int[] dist;	// 거리 배열
        	
        	public static void main(String[] args) {
        		Scanner sc = new Scanner(System.in);
        		
        		int V = sc.nextInt();	// 정점의 개수
        		int E = sc.nextInt();	// 간선의 개수
        		
        		adjList = new ArrayList[V];
        		for (int i = 0; i < V; i++) adjList[i] = new ArrayList<>();
        		
        		dist = new int[V];
        		Arrays.fill(dist, INF);
        		
        		for (int i = 0; i < E; i++) 
        			// 시작정점 - 도착정점 - 가중치 순으로 입력
        			adjList[sc.nextInt()].add(new Node(sc.nextInt(), sc.nextInt()));
        		
        		Dijkstra(0);
        		
        		System.out.println(Arrays.toString(dist));
        	}
        
        	private static void Dijkstra(int start) {
        		
        		PriorityQueue<Node> pq = new PriorityQueue<>();		
        		boolean[] visit = new boolean[V];	// 방문처리
        		dist[start] = 0;	// 시작 노드까지의 거리는 0으로 초기화
        		
        		pq.add(new Node(start, 0));
        		
        		while (!pq.isEmpty()) {
        			
        			Node curr = pq.poll();
        			
        			if (visit[curr.v]) continue;	// 이미 방문했다면 비용을 알고 있다는 뜻
        			visit[curr.v] = true;	// 아니라면 선택
        			
        			for (Node node : adjList[curr.v]) {
        				
        				if (!visit[node.v] && dist[node.v] > dist[curr.v] + node.w) {
        					dist[node.v] = dist[curr.v] + node.w;
        					pq.add(new Node(node.v, dist[node.v]));
        				}
        			} 
        		}
        	}	// Dijkstra
        ```