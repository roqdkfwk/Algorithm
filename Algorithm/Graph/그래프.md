# 그래프

- **그래프**
    - **그래프**
        - 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계 표현
        - 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료구조
        - 선형 자료구조나 트리로 표현하기 어려운 M : N의 관계를 표현한 것
        - V개의 정점을 가지는 그래프는 최대 V x (V - 1) / 2간선이 가능
    
    - **그래프 종류**
        - **무향 그래프(Undirected Graph)** & **유향 그래프(Directed Graph)**
        - **가중치 그래프(Weighted Graph)**
        - **순환 그래프(Cycle Graph)**
        - **비 순환 방향 그래프(DAG, Directed Acyclie Graph)**
    
    - **완전 그래프**
        - 정점들에 대해 가능한 모든 간선들을 가진 그래프
        - 모든 정점은 인접하다.
    
    - **부분 그래프**
        - 일부 간선들을 가진 그래프
    
    - **인접 (Adjacency)**
        - 두 개의 정점에 간선이 존재하면 서로 인접한 것
        - 완전 그래프에 속한 임의의 두 정점은 모두 인접
    
    - **경로(Path)**
        - 간선들을 순서대로 나열한 것
        - 하나의 정점을 한 번만 지나는 경로를 **단순 경로**라 한다.
        - 시작 정점에서 끝나는 경로를 **사이클(Cycle)**이라고 한다.
- **그래프 표현 방법**
    - 간선의 정보를 저장하는 방식, 메모리나 성능을 고려하여 결정
        - **인접 행렬(Adjacent Matrix)**
        - **인접 리스트(Adjacent List)**
        - **간선 배열(Edge Array)**
    
    - **인접 행렬(Adjacent Matrix)**
        - 두 정점을 연결하는 간선의 유무를 행렬로 표현
        - V x V개의 2차원 배열 (V는 정점의 개수, 정점의 번호가 1번부터 시작한다면 
        (V + 1) x (V + 1)개의 2차원 배열)
        - 행 번호화 열 번호는 그래프의 정점 번호
        - 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현 (가중치가 있다면 해당 값으로 작성)
        - 무향 그래프 >> i번째 행의 합 = i번째 열의 합 = V_i의 차수
        - 유향 그래프 >> i번째 행의 합 = V_i의 진출 차수, i번째 열의 합 = V_i의 진입 차수
    
    - **인접 리스트**
        - 각 정점에 대한 인접 정점들을 순차적으로 표현
        - 하나의 정점에 대한 인접 정점들을 각 노드로 하는 연결리스트로 저장
    
    - **간선 배열**
        - 정점과 정점의 연결 정보인 간선을 배열에 저장
        - 간선을 표현하는 두 정점의 정보를 배열 혹은 객체로 저장할 수 있음
    
- **그래프 탐색**
    - 모든 노드를 빠짐 없이 탐색하는 방법은 두 가지가 있따.
        - **깊이 우선 탐색(Depth First Search, DFS)**
        - **너비 우선 탐색(Breadth First Search, BFS)**
    
    - **깊이 우선 탐색(DFS)**
        - 시작 지점에서 출발하여 한 방향으로 탐색함
        - 진행할 수 없다면 마지막에 만난 지점으로 돌아와 다른 방향 다시 탐색
        - 후입 선출(LIFO) 구조의 **스택(Stack)** 사용
        - 재귀함수는 System Stack을 활용하므로 간단하게 구현 가능
    
    - **너비 우선 탐색(BFS)**
        - 시작 지점에 인접한 순으로 탐색을 시작함
        - 인접한 지점을 모두 방문하였다면 다음으로 인접한 지점을 방문함
        - 선입 선출(FIFO) 구조의 **큐(Queue)** 사용
        - 너비 우선 탐색은 인접한 지점부터 방문을 하므로 시작 지점과 끝 지점이 주어졌을 때 **최단 길이**를 구할 수 있다.
- **서로소 집합**
    - **상호 배타 집합**
        - 중복 포함된 원소가 없는 집합 >> 교집합이 없다
        - 각 집합은 대표자를 통해 구분
    
    - **상호 배타 집합 표현 방법**
        - **트리**
        - **연결리스트**
    
    - 상호 배타 집합 연산
        - **Make-Set(x)**
        - **Find-Set(x) : 대표를 찾는 것**
        - **Union(x, y) : 합치는 것, 대표는 x**
    
    - **상호 배타 집합 표현 - 연결리스트**
        - 같은 집합의 원소들은 하나의 연결리스트로 관리
        - 연결리스트의 맨 앞의 원소를 집합의 대표자로 결정
        - 각 원소는 집합의 대표 원소를 가리키는 링크를 갖는다.
    
    - **상호 배타 집합 표현 - 트리**
        - 하나의 집합을 하나의 트리로 표현한다
        - 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다.
    
    - **연산의 효율을 높이는 방법**
        - Rank를 이용한 Union
            - 각 노드는 자신을 루트로 하는 subtree의 높이를 랭크(rank)라는 이름으로 저장
            - 두 집합을 Union할 때 **rank가 낮은 집합을 높은 집합**에 붙인다.
        - Path Compression
            - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 대표를 가리키도록 
            수정한다.
    
    - **Make_set( ) 연산**
        - 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산
        - 반복문을 이용하여 간소화
        - p[x] : 노드 x의 부모 저장
        - rank[x] : 루트 노드가 x인 트리의 랭크 값 저장
    
    - **Find-Set연산**
        - Find-Set(x) : x를 포함하는 집합을 찾는 연산
        - 특정 노드에서 루트 노드까지의 경로를 찾아 가면서 노드 부모의 정보를 갱신
        
        ```java
        private static int findset(int x) {		
        
        		if (x != p[x]) 
        			p[x] = findset(p[x]);
        			
        		return p[x];
        }
        ```
        
    
    - **Union 연산**
        - Union(x, y) : x와 y를 포함하는 두 집합을 합하는 연산
        
        ```java
        private static void union(int x, int y) {
        		
        		x = findset(x);
        		y = findset(y);
        
        		if (x != y) {
        			p[y] = x;
        		}
        }
        ```
        
- **최소 비용 신장 트리(Minimum Spanning Tree)**
    - **신장 트리**
        - 그래프의 모든 정점과 간선의 부분 집합으로 구성되는 트리
    
    - **최소 신장 트리**
        - 신장 트리 중에서 사용된 **간선들의 가중치 합이 최소인 트리**
        - 무방향 가중치 그래프
        - N개의 정점을 가지는 그래프에 대해 **반드시 (N - 1)개의 간선을 사용**
        - 사이클을 포함하지 않는다.
    
    - **사용하는 이유**
        - 도로망, 통신망, 유통망 등등 여러 분야에서 비용을 최소로 해야 이익을 볼 수 있다.
        - 대표적인 알고리즘으로 **크루스칼**, **프림**이 있다.
    - **풀어 볼 만한 문제**
        - BOJ_1197 - [최소 스패닝 트리](https://www.acmicpc.net/problem/1197)
        - BOJ_1922 - [네트워크 연결](https://www.acmicpc.net/problem/1922)
        - SWEA_1251 - [하나로](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15StKqAQkCFAYD&categoryId=AV15StKqAQkCFAYD&categoryType=CODE&problemTitle=1251&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)
        - SWEA_3289 - [서로소 집합](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWBJKA6qr2oDFAWr&categoryId=AWBJKA6qr2oDFAWr&categoryType=CODE&problemTitle=3289&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)